use p3_field::Field;
use p3_maybe_rayon::prelude::{
    IndexedParallelIterator, IntoParallelRefMutIterator, ParallelIterator,
};

use crate::poly::multilinear::MultilinearPoint;

/// Represents a univariate polynomial returned by a sumcheck round.
///
/// This structure holds the evaluations of a univariate polynomial `h(X)` that the
/// prover sends to the verifier in each round of a sumcheck protocol.
///
/// The evaluation domain depends on the protocol variant:
/// - **Standard Sumcheck:** The polynomial is quadratic, and its evaluations are given
///   over the ternary domain `{0, 1, 2}`.
/// - **Univariate Skip:** The polynomial is high-degree, and its evaluations are given
///   over a large multiplicative coset (a power-of-two sized domain).
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct SumcheckPolynomial<F> {
    /// Number of variables in the polynomial (defines the dimension of the evaluation domain).
    n_variables: usize,
    /// Vector of the polynomial's evaluations over its specific domain.
    evaluations: Vec<F>,
}

impl<F> SumcheckPolynomial<F>
where
    F: Field,
{
    /// Creates a new sumcheck polynomial from its evaluations and number of variables.
    ///
    /// # Parameters
    /// - `evaluations`: A vector of function values over the polynomial's domain.
    /// - `n_variables`: The number of variables (almost always 1).
    #[must_use]
    pub const fn new(evaluations: Vec<F>, n_variables: usize) -> Self {
        Self {
            n_variables,
            evaluations,
        }
    }

    /// Returns the vector of stored evaluations.
    #[must_use]
    pub fn evaluations(&self) -> &[F] {
        &self.evaluations
    }

    /// Computes the sum of function values over the Boolean hypercube `{0,1}^n_variables`.
    ///
    /// Instead of summing over all `3^n` evaluations, this method only sums over points where all
    /// coordinates are 0 or 1.
    ///
    /// Mathematically, this computes:
    /// ```ignore
    /// sum = ∑ f(x_1, ..., x_n)  where  (x_1, ..., x_n) ∈ {0,1}^n
    /// ```
    ///
    /// # Warning
    /// This method is **only valid for standard sumcheck polynomials** whose domain
    /// is `{0,1,2}^n`. It will produce incorrect results if used on a polynomial
    /// generated by the univariate skip optimization.
    #[must_use]
    pub fn sum_over_boolean_hypercube(&self) -> F {
        (0..(1 << self.n_variables))
            .map(|point| self.evaluations[self.binary_to_ternary_index(point)])
            .sum()
    }

    /// Converts a binary index `(0..2^n)` to its corresponding ternary index `(0..3^n)`.
    ///
    /// This maps a Boolean hypercube `{0,1}^n` to the ternary hypercube `{0,1,2}^n`.
    ///
    /// Given a binary index:
    /// ```ignore
    /// binary_index = b_{n-1} b_{n-2} ... b_0  (in bits)
    /// ```
    /// The corresponding **ternary index** is computed as:
    /// ```ignore
    /// ternary_index = b_0 * 3^0 + b_1 * 3^1 + ... + b_{n-1} * 3^{n-1}
    /// ```
    ///
    /// # Example:
    /// ```ignore
    /// binary index 0b11  (3 in decimal)  →  ternary index 4
    /// binary index 0b10  (2 in decimal)  →  ternary index 3
    /// binary index 0b01  (1 in decimal)  →  ternary index 1
    /// binary index 0b00  (0 in decimal)  →  ternary index 0
    /// ```
    fn binary_to_ternary_index(&self, mut binary_index: usize) -> usize {
        let mut ternary_index = 0;
        let mut factor = 1;

        for _ in 0..self.n_variables {
            ternary_index += (binary_index & 1) * factor;
            // Move to next bit
            binary_index >>= 1;
            // Increase ternary place value
            factor *= 3;
        }

        ternary_index
    }

    /// Evaluates the polynomial at an arbitrary point in the domain `{0,1,2}^n`.
    ///
    /// Given an interpolation point `point ∈ F^n`, this computes:
    /// ```ignore
    /// f(point) = ∑ evaluations[i] * eq_poly3(i)
    /// ```
    /// where `eq_poly3(i)` is the Lagrange basis polynomial at index `i` in `{0,1,2}^n`.
    ///
    /// This allows evaluating the polynomial at non-discrete inputs beyond `{0,1,2}^n`.
    ///
    /// # Constraints:
    /// - The input `point` must have `n_variables` dimensions.
    ///
    /// # Warning
    /// This method is **only valid for standard (non-skip) sumcheck polynomials**.
    ///
    /// It performs Lagrange interpolation over the `{0,1,2}` domain and will produce
    /// incorrect results for polynomials generated by the univariate skip optimization.
    #[must_use]
    #[inline]
    pub fn evaluate_on_standard_domain(&self, point: &MultilinearPoint<F>) -> F
    where
        F: Send + Sync,
    {
        assert_eq!(point.num_variables(), self.n_variables);
        let n_vars = self.n_variables;
        if n_vars == 0 {
            // If there are no variables, the polynomial is a constant.
            return self.evaluations.first().copied().unwrap_or(F::ZERO);
        }

        // Start with the full set of evaluations.
        let mut evals = self.evaluations.clone();

        // Iteratively fold the evaluation table one dimension at a time.
        //
        // We iterate in reverse to process from the last variable (fastest-moving index) to the first.
        for &p_i in point.iter().rev() {
            // Pre-compute Lagrange evaluations for the current point coordinate p_i.
            let p_i_min_1 = p_i - F::ONE;
            let p_i_sq_min_p_i = p_i * p_i_min_1;
            let lagrange_evals = [
                // L_0(p_i)
                //
                // (val - 1)(val - 2) / 2
                // = (val^2 - 3val + 2)/2
                // = (val^2 - val - 2val + 2)/2
                // = (val(val-1) - 2(val-1))/2
                // = val(val-1)/2 - (val-1)
                p_i_sq_min_p_i.halve() - p_i_min_1,
                // L_1(p_i)
                //
                // -val * (val - 2) = -val^2 + 2val = -val(val-1) + val
                p_i - p_i_sq_min_p_i,
                // L_2(p_i)
                //
                // val * (val - 1) / 2
                p_i_sq_min_p_i.halve(),
            ];

            // The size of the table for the remaining variables.
            let next_size = evals.len() / 3;

            // Create the next, smaller evaluation table.
            let mut next_evals = F::zero_vec(next_size);

            // Compute the weighted sum for each entry in the new table.
            //
            // Via experimentations, it was found that:
            // - For < 12 variables, the sequential version is faster.
            // - For >= 12 variables, the parallel version is faster.
            //
            // TODO: we may define a constant for this.
            if n_vars < 12 {
                next_evals.iter_mut().enumerate().for_each(|(j, res)| {
                    *res = evals[3 * j] * lagrange_evals[0]
                        + evals[3 * j + 1] * lagrange_evals[1]
                        + evals[3 * j + 2] * lagrange_evals[2];
                });
            } else {
                next_evals.par_iter_mut().enumerate().for_each(|(j, res)| {
                    *res = evals[3 * j] * lagrange_evals[0]
                        + evals[3 * j + 1] * lagrange_evals[1]
                        + evals[3 * j + 2] * lagrange_evals[2];
                });
            }

            evals = next_evals;
        }

        // After all dimensions are folded, only one value remains.
        evals[0]
    }
}

#[cfg(test)]
mod tests {
    use p3_baby_bear::BabyBear;
    use p3_field::PrimeCharacteristicRing;

    use super::*;

    type F = BabyBear;

    #[test]
    #[should_panic]
    fn test_evaluate_on_standard_domain_wrong_dimensions() {
        let poly = SumcheckPolynomial::new(vec![F::ZERO; 9], 2);
        let point = MultilinearPoint(vec![F::ONE]); // Wrong dimension
        assert_eq!(poly.evaluate_on_standard_domain(&point), F::ZERO);
    }

    #[test]
    fn test_all_zero_evaluations() {
        let poly = SumcheckPolynomial::new(vec![F::ZERO; 9], 2);
        assert_eq!(poly.sum_over_boolean_hypercube(), F::ZERO);

        let point = MultilinearPoint(vec![F::from_u64(5), F::from_u64(7)]);
        assert_eq!(poly.evaluate_on_standard_domain(&point), F::ZERO);
    }

    #[test]
    fn test_single_nonzero_evaluation() {
        let mut evaluations = vec![F::ZERO; 9];
        evaluations[4] = F::from_u64(100); // f(1,1) = 100
        let poly = SumcheckPolynomial::new(evaluations, 2);

        // Only f(1,1) contributes to boolean sum
        assert_eq!(poly.sum_over_boolean_hypercube(), F::from_u64(100));
    }

    #[test]
    fn test_binary_to_ternary_systematic() {
        for n_vars in 1..=4 {
            let total_evals = 3_usize.pow(n_vars as u32);
            let poly = SumcheckPolynomial::new(vec![F::ZERO; total_evals], n_vars);

            let mut used_indices = std::collections::HashSet::new();
            for binary_idx in 0..(1 << n_vars) {
                let ternary_idx = poly.binary_to_ternary_index(binary_idx);
                assert!(ternary_idx < total_evals);
                assert!(used_indices.insert(ternary_idx), "Duplicate ternary index");
            }
        }
    }

    #[test]
    fn test_binary_to_ternary_index() {
        let poly = SumcheckPolynomial::new(vec![F::ZERO; 9], 2);

        // Binary indices: 0, 1, 2, 3 (for 2 variables: {00, 01, 10, 11})
        // Corresponding ternary indices: 0, 1, 3, 4
        assert_eq!(poly.binary_to_ternary_index(0b00), 0);
        assert_eq!(poly.binary_to_ternary_index(0b01), 1);
        assert_eq!(poly.binary_to_ternary_index(0b10), 3);
        assert_eq!(poly.binary_to_ternary_index(0b11), 4);
    }

    #[test]
    fn test_binary_to_ternary_index_three_vars() {
        let poly = SumcheckPolynomial::new(vec![F::ZERO; 27], 3);

        // Check conversion for all binary points in {0,1}^3
        assert_eq!(poly.binary_to_ternary_index(0b000), 0);
        assert_eq!(poly.binary_to_ternary_index(0b001), 1);
        assert_eq!(poly.binary_to_ternary_index(0b010), 3);
        assert_eq!(poly.binary_to_ternary_index(0b011), 4);
        assert_eq!(poly.binary_to_ternary_index(0b100), 9);
        assert_eq!(poly.binary_to_ternary_index(0b101), 10);
        assert_eq!(poly.binary_to_ternary_index(0b110), 12);
        assert_eq!(poly.binary_to_ternary_index(0b111), 13);
    }

    #[test]
    fn test_sum_over_boolean_hypercube_single_var() {
        // Test case for a single variable (n_variables = 1)
        // Function values at {0,1,2}: f(0) = 3, f(1) = 5, f(2) = 7
        let evaluations = vec![
            F::from_u64(3), // f(0)
            F::from_u64(5), // f(1)
            F::from_u64(7), // f(2)
        ];
        let poly = SumcheckPolynomial::new(evaluations, 1);

        // Sum over {0,1}: f(0) + f(1)
        let expected_sum = F::from_u64(3) + F::from_u64(5);
        assert_eq!(poly.sum_over_boolean_hypercube(), expected_sum);
    }

    #[test]
    fn test_sum_over_boolean_hypercube() {
        // Define a simple function f such that:
        // f(0,0) = 1, f(0,1) = 2, f(0,2) = 3
        // f(1,0) = 4, f(1,1) = 5, f(1,2) = 6
        // f(2,0) = 7, f(2,1) = 8, f(2,2) = 9
        let evaluations: Vec<_> = (1..=9).map(F::from_u64).collect();
        let poly = SumcheckPolynomial::new(evaluations, 2);

        // Sum over {0,1}^2: f(0,0) + f(0,1) + f(1,0) + f(1,1)
        let expected_sum = F::from_u64(1) + F::from_u64(2) + F::from_u64(4) + F::from_u64(5);
        let computed_sum = poly.sum_over_boolean_hypercube();
        assert_eq!(computed_sum, expected_sum);
    }

    #[test]
    fn test_sum_over_boolean_hypercube_three_vars() {
        // Test case for three variables (n_variables = 3)
        // Evaluations indexed lexicographically in {0,1,2}^3:
        //
        // f(0,0,0) = 1  f(0,0,1) = 2  f(0,0,2) = 3
        // f(0,1,0) = 4  f(0,1,1) = 5  f(0,1,2) = 6
        // f(0,2,0) = 7  f(0,2,1) = 8  f(0,2,2) = 9
        //
        // f(1,0,0) = 10 f(1,0,1) = 11 f(1,0,2) = 12
        // f(1,1,0) = 13 f(1,1,1) = 14 f(1,1,2) = 15
        // f(1,2,0) = 16 f(1,2,1) = 17 f(1,2,2) = 18
        //
        // f(2,0,0) = 19 f(2,0,1) = 20 f(2,0,2) = 21
        // f(2,1,0) = 22 f(2,1,1) = 23 f(2,1,2) = 24
        // f(2,2,0) = 25 f(2,2,1) = 26 f(2,2,2) = 27
        let evaluations: Vec<_> = (1..=27).map(F::from_u64).collect();
        let poly = SumcheckPolynomial::new(evaluations, 3);

        // Sum over {0,1}^3
        let expected_sum = F::from_u64(1)
            + F::from_u64(2)
            + F::from_u64(4)
            + F::from_u64(5)
            + F::from_u64(10)
            + F::from_u64(11)
            + F::from_u64(13)
            + F::from_u64(14);

        assert_eq!(poly.sum_over_boolean_hypercube(), expected_sum);
    }

    #[test]
    fn test_linearity_of_evaluate_on_standard_domain() {
        let evals1: Vec<_> = (1..=9).map(F::from_u64).collect();
        let evals2: Vec<_> = (10..=18).map(F::from_u64).collect();
        let poly1 = SumcheckPolynomial::new(evals1.clone(), 2);
        let poly2 = SumcheckPolynomial::new(evals2.clone(), 2);

        // Create combined polynomial: poly1 + 2*poly2
        let combined_evals: Vec<_> = evals1
            .iter()
            .zip(evals2.iter())
            .map(|(&e1, &e2)| e1 + e2.double())
            .collect();
        let combined_poly = SumcheckPolynomial::new(combined_evals, 2);

        let point = MultilinearPoint(vec![F::from_u64(3), F::from_u64(7)]);
        let expected = poly1.evaluate_on_standard_domain(&point)
            + poly2.evaluate_on_standard_domain(&point).double();
        assert_eq!(combined_poly.evaluate_on_standard_domain(&point), expected);
    }

    #[test]
    fn test_evaluate_on_standard_domain() {
        // Define a function f where evaluations are hardcoded:
        // f(0,0) = 1, f(0,1) = 2, f(0,2) = 3
        // f(1,0) = 4, f(1,1) = 5, f(1,2) = 6
        // f(2,0) = 7, f(2,1) = 8, f(2,2) = 9
        let evaluations: Vec<_> = (1..=9).map(F::from_u64).collect();
        let poly = SumcheckPolynomial::new(evaluations, 2);

        // Define an evaluation point (0.5, 0.5) as an interpolation between {0,1,2}^2
        let point = MultilinearPoint(vec![F::from_u64(1) / F::from_u64(2); 2]);

        let result = poly.evaluate_on_standard_domain(&point);

        // Compute the expected result using the full weighted sum:
        let expected_value = F::from_u64(1) * point.eq_poly3(0)
            + F::from_u64(2) * point.eq_poly3(1)
            + F::from_u64(3) * point.eq_poly3(2)
            + F::from_u64(4) * point.eq_poly3(3)
            + F::from_u64(5) * point.eq_poly3(4)
            + F::from_u64(6) * point.eq_poly3(5)
            + F::from_u64(7) * point.eq_poly3(6)
            + F::from_u64(8) * point.eq_poly3(7)
            + F::from_u64(9) * point.eq_poly3(8);

        assert_eq!(result, expected_value);
    }

    #[test]
    fn test_evaluate_on_standard_domain_three_vars() {
        // Define a function with three variables
        let evaluations: Vec<_> = (1..=27).map(F::from_u64).collect();
        let poly = SumcheckPolynomial::new(evaluations, 3);

        // Define an interpolation point (1/2, 1/2, 1/2) in {0,1,2}^3
        let point = MultilinearPoint(vec![F::from_u64(1) / F::from_u64(2); 3]);

        // Compute expected evaluation:
        let expected_value = (0..27)
            .map(|i| poly.evaluations[i] * point.eq_poly3(i))
            .sum::<F>();

        let computed_value = poly.evaluate_on_standard_domain(&point);
        assert_eq!(computed_value, expected_value);
    }
}
