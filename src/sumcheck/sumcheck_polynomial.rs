use p3_field::Field;
use p3_maybe_rayon::prelude::*;

use crate::poly::multilinear::MultilinearPoint;

/// A constant to determine when to switch from sequential to parallel execution.
///
/// Through benchmarking, 12 variables is a good crossover point
/// where the overhead of thread management becomes worth the performance gain.
const PARALLEL_THRESHOLD: usize = 12;

/// Represents a univariate polynomial returned by a sumcheck round.
///
/// This structure holds the evaluations of a univariate polynomial `h(X)` that the
/// prover sends to the verifier in each round of a sumcheck protocol.
///
/// The evaluation domain depends on the protocol variant:
/// - **Standard Sumcheck:** The polynomial is quadratic, and its evaluations are given
///   over the ternary domain `{0, 1, 2}`.
/// - **Univariate Skip:** The polynomial is high-degree, and its evaluations are given
///   over a large multiplicative coset (a power-of-two sized domain).
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct SumcheckPolynomial<F> {
    /// Number of variables in the polynomial (defines the dimension of the evaluation domain).
    n_variables: usize,
    /// Vector of the polynomial's evaluations over its specific domain.
    evaluations: Vec<F>,
}

impl<F> SumcheckPolynomial<F>
where
    F: Field,
{
    /// Creates a new sumcheck polynomial from its evaluations and number of variables.
    ///
    /// # Parameters
    /// - `evaluations`: A vector of function values over the polynomial's domain.
    /// - `n_variables`: The number of variables (almost always 1).
    #[must_use]
    pub const fn new(evaluations: Vec<F>, n_variables: usize) -> Self {
        Self {
            n_variables,
            evaluations,
        }
    }

    /// Returns the vector of stored evaluations.
    #[must_use]
    pub fn evaluations(&self) -> &[F] {
        &self.evaluations
    }

    /// Computes the sum of function values over the Boolean hypercube `{0,1}^n_variables`.
    ///
    /// Instead of summing over all `3^n` evaluations, this method only sums over points where all
    /// coordinates are 0 or 1.
    ///
    /// Mathematically, this computes:
    /// ```ignore
    /// sum = ∑ f(x_1, ..., x_n)  where  (x_1, ..., x_n) ∈ {0,1}^n
    /// ```
    ///
    /// # Warning
    /// This method is **only valid for standard sumcheck polynomials** whose domain
    /// is `{0,1,2}^n`. It will produce incorrect results if used on a polynomial
    /// generated by the univariate skip optimization.
    #[must_use]
    pub fn sum_over_boolean_hypercube(&self) -> F {
        (0..(1 << self.n_variables))
            .map(|point| self.evaluations[self.binary_to_ternary_index(point)])
            .sum()
    }

    /// Converts a binary index `(0..2^n)` to its corresponding ternary index `(0..3^n)`.
    ///
    /// This maps a Boolean hypercube `{0,1}^n` to the ternary hypercube `{0,1,2}^n`.
    ///
    /// Given a binary index:
    /// ```ignore
    /// binary_index = b_{n-1} b_{n-2} ... b_0  (in bits)
    /// ```
    /// The corresponding **ternary index** is computed as:
    /// ```ignore
    /// ternary_index = b_0 * 3^0 + b_1 * 3^1 + ... + b_{n-1} * 3^{n-1}
    /// ```
    ///
    /// # Example:
    /// ```ignore
    /// binary index 0b11  (3 in decimal)  →  ternary index 4
    /// binary index 0b10  (2 in decimal)  →  ternary index 3
    /// binary index 0b01  (1 in decimal)  →  ternary index 1
    /// binary index 0b00  (0 in decimal)  →  ternary index 0
    /// ```
    fn binary_to_ternary_index(&self, mut binary_index: usize) -> usize {
        let mut ternary_index = 0;
        let mut factor = 1;

        for _ in 0..self.n_variables {
            ternary_index += (binary_index & 1) * factor;
            // Move to next bit
            binary_index >>= 1;
            // Increase ternary place value
            factor *= 3;
        }

        ternary_index
    }

    /// Evaluates the polynomial at an arbitrary point in the domain `{0,1,2}^n`.
    ///
    /// Given an interpolation point `point ∈ F^n`, this computes:
    /// ```ignore
    /// f(point) = ∑ evaluations[i] * eq_poly3(i)
    /// ```
    /// where `eq_poly3(i)` is the Lagrange basis polynomial at index `i` in `{0,1,2}^n`.
    ///
    /// This allows evaluating the polynomial at non-discrete inputs beyond `{0,1,2}^n`.
    ///
    /// # Constraints:
    /// - The input `point` must have `n_variables` dimensions.
    ///
    /// # Warning
    /// This method is **only valid for standard (non-skip) sumcheck polynomials**.
    ///
    /// It performs Lagrange interpolation over the `{0,1,2}` domain and will produce
    /// incorrect results for polynomials generated by the univariate skip optimization.
    #[must_use]
    #[inline]
    pub fn evaluate_on_standard_domain(&self, point: &MultilinearPoint<F>) -> F
    where
        F: Send + Sync,
    {
        assert_eq!(point.num_variables(), self.n_variables);
        let n_vars = self.n_variables;
        if n_vars == 0 {
            // If there are no variables, the polynomial is a constant.
            return self.evaluations.first().copied().unwrap_or(F::ZERO);
        }

        // Ping-Pong Buffer Strategy:
        //
        // We allocate two buffers upfront to avoid allocations in the loop.

        // Start with the full set of evaluations.
        let mut current_evals = self.evaluations.clone();
        // The destination buffer for the next folded state.
        let mut next_evals = F::zero_vec(self.evaluations.len() / 3);

        // Iteratively fold the evaluation table one dimension at a time.
        //
        // We iterate in reverse to process from the last variable (fastest-moving index) to the first.
        for (i, &p_i) in point.iter().rev().enumerate() {
            let p_i_min_1 = p_i - F::ONE;
            let p_i_sq_min_p_i = p_i * p_i_min_1;
            let p_i_sq_min_p_i_halve = p_i_sq_min_p_i.halve();
            let lagrange_evals = [
                // L_0(p_i) = (p_i - 1)(p_i - 2) / 2
                //
                // (p_i - 1)(p_i - 2) / 2
                // = (p_i^2 - p_i + 2)/2
                // = (p_i^2 - p_i - p_i + 2)/2
                // = (p_i(p_i-1) - 2(p_i-1))/2
                // = p_i(p_i-1)/2 - (p_i-1)
                p_i_sq_min_p_i_halve - p_i_min_1,
                // L_1(p_i) = -p_i(p_i - 2)
                //
                // -p_i * (p_i - 2)
                // = -p_i^2 + p_i
                // = -p_i(p_i-1) + val
                p_i - p_i_sq_min_p_i,
                // L_2(p_i) = p_i(p_i - 1) / 2
                //
                // p_i * (p_i - 1) / 2
                p_i_sq_min_p_i_halve,
            ];

            // Determine the source and destination buffers for this iteration.
            let (source, dest) = if i.is_multiple_of(2) {
                (&current_evals, &mut next_evals)
            } else {
                (&next_evals, &mut current_evals)
            };

            // Ensure the destination buffer is the correct size for this folding step.
            let next_size = source.len() / 3;
            dest.truncate(next_size);

            // The core computation, defined as a lambda to avoid duplication.
            let compute_fold = |(res, chunk): (&mut F, &[F])| {
                *res = F::dot_product(chunk.try_into().unwrap(), &lagrange_evals);
            };

            // Use parallel execution for large inputs, sequential for small ones.
            if n_vars > PARALLEL_THRESHOLD {
                dest.par_iter_mut()
                    .zip(source.par_chunks_exact(3))
                    .for_each(compute_fold);
            } else {
                dest.iter_mut()
                    .zip(source.chunks_exact(3))
                    .for_each(compute_fold);
            }
        }

        // After all dimensions are folded, only one value remains.
        // The final result is in one of the two buffers, depending on n_vars.
        if n_vars.is_multiple_of(2) {
            // After an even number of folds, the result is back in `current_evals`.
            current_evals[0]
        } else {
            // After an odd number of folds, the result is in `next_evals`.
            next_evals[0]
        }
    }
}

#[cfg(test)]
mod tests {
    use p3_baby_bear::BabyBear;
    use p3_field::PrimeCharacteristicRing;

    use super::*;

    type F = BabyBear;

    /// This function computes the Lagrange basis polynomial for the domain `{0,1,2}^n`
    /// by directly applying the textbook formulas.
    ///
    /// It computes:
    /// `Π L_{p_i}(c_i)`
    ///
    /// where `(p_1, ..., p_n)` are the ternary digits of `point_idx`, `(c_1, ..., c_n)`
    /// are the coordinates of `eval_point`, and `L_j(x)` are the univariate Lagrange
    /// basis polynomials for the domain `{0, 1, 2}`.
    fn eq_poly3(eval_point: &MultilinearPoint<F>, mut point_idx: usize) -> F {
        let n_vars = eval_point.num_variables();
        assert!(point_idx < 3usize.pow(n_vars as u32));

        let mut acc = F::ONE;
        let two_inv = F::TWO.inverse();

        // Iterate through variables in little-endian order.
        for &c_i in eval_point.iter().rev() {
            let p_i = point_idx % 3;

            let lagrange_eval = match p_i {
                // L_0(x) = (x-1)(x-2)/2
                0 => (c_i - F::ONE) * (c_i - F::TWO) * two_inv,
                // L_1(x) = -x(x-2)
                1 => -c_i * (c_i - F::TWO),
                // L_2(x) = x(x-1)/2
                2 => c_i * (c_i - F::ONE) * two_inv,
                _ => unreachable!(),
            };
            acc *= lagrange_eval;
            point_idx /= 3;
        }
        acc
    }

    #[test]
    #[should_panic]
    fn test_evaluate_on_standard_domain_wrong_dimensions() {
        let poly = SumcheckPolynomial::new(vec![F::ZERO; 9], 2);
        let point = MultilinearPoint(vec![F::ONE]); // Wrong dimension
        assert_eq!(poly.evaluate_on_standard_domain(&point), F::ZERO);
    }

    #[test]
    fn test_all_zero_evaluations() {
        let poly = SumcheckPolynomial::new(vec![F::ZERO; 9], 2);
        assert_eq!(poly.sum_over_boolean_hypercube(), F::ZERO);

        let point = MultilinearPoint(vec![F::from_u64(5), F::from_u64(7)]);
        assert_eq!(poly.evaluate_on_standard_domain(&point), F::ZERO);
    }

    #[test]
    fn test_single_nonzero_evaluation() {
        let mut evaluations = vec![F::ZERO; 9];
        evaluations[4] = F::from_u64(100); // f(1,1) = 100
        let poly = SumcheckPolynomial::new(evaluations, 2);

        // Only f(1,1) contributes to boolean sum
        assert_eq!(poly.sum_over_boolean_hypercube(), F::from_u64(100));
    }

    #[test]
    fn test_binary_to_ternary_systematic() {
        for n_vars in 1..=4 {
            let total_evals = 3_usize.pow(n_vars as u32);
            let poly = SumcheckPolynomial::new(vec![F::ZERO; total_evals], n_vars);

            let mut used_indices = std::collections::HashSet::new();
            for binary_idx in 0..(1 << n_vars) {
                let ternary_idx = poly.binary_to_ternary_index(binary_idx);
                assert!(ternary_idx < total_evals);
                assert!(used_indices.insert(ternary_idx), "Duplicate ternary index");
            }
        }
    }

    #[test]
    fn test_binary_to_ternary_index() {
        let poly = SumcheckPolynomial::new(vec![F::ZERO; 9], 2);

        // Binary indices: 0, 1, 2, 3 (for 2 variables: {00, 01, 10, 11})
        // Corresponding ternary indices: 0, 1, 3, 4
        assert_eq!(poly.binary_to_ternary_index(0b00), 0);
        assert_eq!(poly.binary_to_ternary_index(0b01), 1);
        assert_eq!(poly.binary_to_ternary_index(0b10), 3);
        assert_eq!(poly.binary_to_ternary_index(0b11), 4);
    }

    #[test]
    fn test_binary_to_ternary_index_three_vars() {
        let poly = SumcheckPolynomial::new(vec![F::ZERO; 27], 3);

        // Check conversion for all binary points in {0,1}^3
        assert_eq!(poly.binary_to_ternary_index(0b000), 0);
        assert_eq!(poly.binary_to_ternary_index(0b001), 1);
        assert_eq!(poly.binary_to_ternary_index(0b010), 3);
        assert_eq!(poly.binary_to_ternary_index(0b011), 4);
        assert_eq!(poly.binary_to_ternary_index(0b100), 9);
        assert_eq!(poly.binary_to_ternary_index(0b101), 10);
        assert_eq!(poly.binary_to_ternary_index(0b110), 12);
        assert_eq!(poly.binary_to_ternary_index(0b111), 13);
    }

    #[test]
    fn test_sum_over_boolean_hypercube_single_var() {
        // Test case for a single variable (n_variables = 1)
        // Function values at {0,1,2}: f(0) = 3, f(1) = 5, f(2) = 7
        let evaluations = vec![
            F::from_u64(3), // f(0)
            F::from_u64(5), // f(1)
            F::from_u64(7), // f(2)
        ];
        let poly = SumcheckPolynomial::new(evaluations, 1);

        // Sum over {0,1}: f(0) + f(1)
        let expected_sum = F::from_u64(3) + F::from_u64(5);
        assert_eq!(poly.sum_over_boolean_hypercube(), expected_sum);
    }

    #[test]
    fn test_sum_over_boolean_hypercube() {
        // Define a simple function f such that:
        // f(0,0) = 1, f(0,1) = 2, f(0,2) = 3
        // f(1,0) = 4, f(1,1) = 5, f(1,2) = 6
        // f(2,0) = 7, f(2,1) = 8, f(2,2) = 9
        let evaluations: Vec<_> = (1..=9).map(F::from_u64).collect();
        let poly = SumcheckPolynomial::new(evaluations, 2);

        // Sum over {0,1}^2: f(0,0) + f(0,1) + f(1,0) + f(1,1)
        let expected_sum = F::from_u64(1) + F::from_u64(2) + F::from_u64(4) + F::from_u64(5);
        let computed_sum = poly.sum_over_boolean_hypercube();
        assert_eq!(computed_sum, expected_sum);
    }

    #[test]
    fn test_sum_over_boolean_hypercube_three_vars() {
        // Test case for three variables (n_variables = 3)
        // Evaluations indexed lexicographically in {0,1,2}^3:
        //
        // f(0,0,0) = 1  f(0,0,1) = 2  f(0,0,2) = 3
        // f(0,1,0) = 4  f(0,1,1) = 5  f(0,1,2) = 6
        // f(0,2,0) = 7  f(0,2,1) = 8  f(0,2,2) = 9
        //
        // f(1,0,0) = 10 f(1,0,1) = 11 f(1,0,2) = 12
        // f(1,1,0) = 13 f(1,1,1) = 14 f(1,1,2) = 15
        // f(1,2,0) = 16 f(1,2,1) = 17 f(1,2,2) = 18
        //
        // f(2,0,0) = 19 f(2,0,1) = 20 f(2,0,2) = 21
        // f(2,1,0) = 22 f(2,1,1) = 23 f(2,1,2) = 24
        // f(2,2,0) = 25 f(2,2,1) = 26 f(2,2,2) = 27
        let evaluations: Vec<_> = (1..=27).map(F::from_u64).collect();
        let poly = SumcheckPolynomial::new(evaluations, 3);

        // Sum over {0,1}^3
        let expected_sum = F::from_u64(1)
            + F::from_u64(2)
            + F::from_u64(4)
            + F::from_u64(5)
            + F::from_u64(10)
            + F::from_u64(11)
            + F::from_u64(13)
            + F::from_u64(14);

        assert_eq!(poly.sum_over_boolean_hypercube(), expected_sum);
    }

    #[test]
    fn test_linearity_of_evaluate_on_standard_domain() {
        let evals1: Vec<_> = (1..=9).map(F::from_u64).collect();
        let evals2: Vec<_> = (10..=18).map(F::from_u64).collect();
        let poly1 = SumcheckPolynomial::new(evals1.clone(), 2);
        let poly2 = SumcheckPolynomial::new(evals2.clone(), 2);

        // Create combined polynomial: poly1 + 2*poly2
        let combined_evals: Vec<_> = evals1
            .iter()
            .zip(evals2.iter())
            .map(|(&e1, &e2)| e1 + e2.double())
            .collect();
        let combined_poly = SumcheckPolynomial::new(combined_evals, 2);

        let point = MultilinearPoint(vec![F::from_u64(3), F::from_u64(7)]);
        let expected = poly1.evaluate_on_standard_domain(&point)
            + poly2.evaluate_on_standard_domain(&point).double();
        assert_eq!(combined_poly.evaluate_on_standard_domain(&point), expected);
    }

    #[test]
    fn test_evaluate_on_standard_domain() {
        // Define a function f where evaluations are hardcoded:
        // f(0,0) = 1, f(0,1) = 2, f(0,2) = 3
        // f(1,0) = 4, f(1,1) = 5, f(1,2) = 6
        // f(2,0) = 7, f(2,1) = 8, f(2,2) = 9
        let evaluations: Vec<_> = (1..=9).map(F::from_u64).collect();
        let poly = SumcheckPolynomial::new(evaluations, 2);

        // Define an evaluation point (0.5, 0.5) as an interpolation between {0,1,2}^2
        let point = MultilinearPoint(vec![F::from_u64(1) / F::from_u64(2); 2]);

        let result = poly.evaluate_on_standard_domain(&point);

        // Compute the expected result using the full weighted sum:
        let expected_value = F::from_u64(1) * eq_poly3(&point, 0)
            + F::from_u64(2) * eq_poly3(&point, 1)
            + F::from_u64(3) * eq_poly3(&point, 2)
            + F::from_u64(4) * eq_poly3(&point, 3)
            + F::from_u64(5) * eq_poly3(&point, 4)
            + F::from_u64(6) * eq_poly3(&point, 5)
            + F::from_u64(7) * eq_poly3(&point, 6)
            + F::from_u64(8) * eq_poly3(&point, 7)
            + F::from_u64(9) * eq_poly3(&point, 8);

        assert_eq!(result, expected_value);
    }

    #[test]
    fn test_evaluate_on_standard_domain_three_vars() {
        // Define a function with three variables
        let evaluations: Vec<_> = (1..=27).map(F::from_u64).collect();
        let poly = SumcheckPolynomial::new(evaluations, 3);

        // Define an interpolation point (1/2, 1/2, 1/2) in {0,1,2}^3
        let point = MultilinearPoint(vec![F::from_u64(1) / F::from_u64(2); 3]);

        // Compute expected evaluation:
        let expected_value = (0..27)
            .map(|i| poly.evaluations[i] * eq_poly3(&point, i))
            .sum::<F>();

        let computed_value = poly.evaluate_on_standard_domain(&point);
        assert_eq!(computed_value, expected_value);
    }
}
