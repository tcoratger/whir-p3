use p3_field::Field;

use crate::poly::multilinear::MultilinearPoint;

/// A constant to determine when to switch from sequential to parallel execution.
///
/// Through benchmarking, 12 variables is a good crossover point
/// where the overhead of thread management becomes worth the performance gain.
const PARALLEL_THRESHOLD: usize = 12;

/// Represents a univariate polynomial returned by a sumcheck round.
///
/// This structure holds the evaluations of a univariate polynomial `h(X)` that the
/// prover sends to the verifier in each round of a sumcheck protocol.
///
/// The evaluation domain depends on the protocol variant:
/// - **Standard Sumcheck:** The polynomial is quadratic, and its evaluations are given
///   over the ternary domain `{0, 1, 2}`.
/// - **Univariate Skip:** The polynomial is high-degree, and its evaluations are given
///   over a large multiplicative coset (a power-of-two sized domain).
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct SumcheckPolynomial<F> {
    /// Vector of the polynomial's evaluations over its specific domain.
    evaluations: Vec<F>,
}

impl<F> SumcheckPolynomial<F>
where
    F: Field,
{
    /// Creates a new sumcheck polynomial from its evaluations and number of variables.
    ///
    /// # Parameters
    /// - `evaluations`: A vector of function values over the polynomial's domain.
    #[must_use]
    pub const fn new(evaluations: Vec<F>) -> Self {
        Self { evaluations }
    }

    /// Returns the vector of stored evaluations.
    #[must_use]
    pub fn evaluations(&self) -> &[F] {
        &self.evaluations
    }

    /// Evaluates the polynomial at an arbitrary point in the domain `{0,1,2}^n`.
    ///
    /// Given an interpolation point `point ∈ F^n`, this computes:
    /// ```ignore
    /// f(point) = ∑ evaluations[i] * eq_poly3(i)
    /// ```
    /// where `eq_poly3(i)` is the Lagrange basis polynomial at index `i` in `{0,1,2}^n`.
    ///
    /// This allows evaluating the polynomial at non-discrete inputs beyond `{0,1,2}^n`.
    ///
    /// # Constraints:
    /// - The input `point` must have `n_variables = 1` dimensions.
    ///
    /// # Warning
    /// This method is **only valid for standard (non-skip) sumcheck polynomials**.
    ///
    /// It performs Lagrange interpolation over the `{0,1,2}` domain and will produce
    /// incorrect results for polynomials generated by the univariate skip optimization.
    #[must_use]
    #[inline]
    pub fn evaluate_on_standard_domain(&self, point: &MultilinearPoint<F>) -> F
    where
        F: Send + Sync,
    {
        assert_eq!(point.num_variables(), 1);

        // Ping-Pong Buffer Strategy:
        //
        // We allocate two buffers upfront to avoid allocations in the loop.

        // Start with the full set of evaluations.
        let mut current_evals = self.evaluations.clone();
        // The destination buffer for the next folded state.
        let mut next_evals = F::zero_vec(self.evaluations.len() / 3);

        // Iteratively fold the evaluation table one dimension at a time.
        //
        // We iterate in reverse to process from the last variable (fastest-moving index) to the first.
        for (i, &p_i) in point.iter().rev().enumerate() {
            let p_i_min_1 = p_i - F::ONE;
            let p_i_sq_min_p_i = p_i * p_i_min_1;
            let p_i_sq_min_p_i_halve = p_i_sq_min_p_i.halve();
            let lagrange_evals = [
                // L_0(p_i) = (p_i - 1)(p_i - 2) / 2
                //
                // (p_i - 1)(p_i - 2) / 2
                // = (p_i^2 - p_i + 2)/2
                // = (p_i^2 - p_i - p_i + 2)/2
                // = (p_i(p_i-1) - 2(p_i-1))/2
                // = p_i(p_i-1)/2 - (p_i-1)
                p_i_sq_min_p_i_halve - p_i_min_1,
                // L_1(p_i) = -p_i(p_i - 2)
                //
                // -p_i * (p_i - 2)
                // = -p_i^2 + p_i
                // = -p_i(p_i-1) + val
                p_i - p_i_sq_min_p_i,
                // L_2(p_i) = p_i(p_i - 1) / 2
                //
                // p_i * (p_i - 1) / 2
                p_i_sq_min_p_i_halve,
            ];

            // Determine the source and destination buffers for this iteration.
            let (source, dest) = if i.is_multiple_of(2) {
                (&current_evals, &mut next_evals)
            } else {
                (&next_evals, &mut current_evals)
            };

            // Ensure the destination buffer is the correct size for this folding step.
            let next_size = source.len() / 3;
            dest.truncate(next_size);

            // Folding
            dest.iter_mut()
                .zip(source.chunks_exact(3))
                .for_each(|(res, chunk): (&mut F, &[F])| {
                    *res = F::dot_product(chunk.try_into().unwrap(), &lagrange_evals);
                });
        }

        // After all dimensions are folded, only one value remains.
        // The final result is in one of the two buffers, depending on number of variables.
        //
        // As our polynomial is always univariate, n_variables = 1.
        //
        // After an odd number of folds (n_variables = 1), the result is in `next_evals`.
        next_evals[0]
    }
}

#[cfg(test)]
mod tests {
    use p3_baby_bear::BabyBear;
    use p3_field::PrimeCharacteristicRing;

    use super::*;

    type F = BabyBear;

    /// This function computes the Lagrange basis polynomial for the domain `{0,1,2}^n`
    /// by directly applying the textbook formulas.
    ///
    /// It computes:
    /// `Π L_{p_i}(c_i)`
    ///
    /// where `(p_1, ..., p_n)` are the ternary digits of `point_idx`, `(c_1, ..., c_n)`
    /// are the coordinates of `eval_point`, and `L_j(x)` are the univariate Lagrange
    /// basis polynomials for the domain `{0, 1, 2}`.
    fn eq_poly3(eval_point: &MultilinearPoint<F>, mut point_idx: usize) -> F {
        let n_vars = eval_point.num_variables();
        assert!(point_idx < 3usize.pow(n_vars as u32));

        let mut acc = F::ONE;
        let two_inv = F::TWO.inverse();

        // Iterate through variables in little-endian order.
        for &c_i in eval_point.iter().rev() {
            let p_i = point_idx % 3;

            let lagrange_eval = match p_i {
                // L_0(x) = (x-1)(x-2)/2
                0 => (c_i - F::ONE) * (c_i - F::TWO) * two_inv,
                // L_1(x) = -x(x-2)
                1 => -c_i * (c_i - F::TWO),
                // L_2(x) = x(x-1)/2
                2 => c_i * (c_i - F::ONE) * two_inv,
                _ => unreachable!(),
            };
            acc *= lagrange_eval;
            point_idx /= 3;
        }
        acc
    }

    #[test]
    #[should_panic]
    fn test_evaluate_on_standard_domain_wrong_dimensions() {
        // A sumcheck polynomial is always univariate, expecting 3 evaluations.
        let poly = SumcheckPolynomial::new(vec![F::ZERO; 3]);
        // The point has 2 variables, but the method asserts it must be 1.
        let point = MultilinearPoint::new(vec![F::ONE, F::ONE]);
        // This should panic due to the dimension mismatch assertion.
        let _ = poly.evaluate_on_standard_domain(&point);
    }

    #[test]
    fn test_all_zero_evaluations() {
        // For a univariate polynomial with 3 evaluations.
        let poly = SumcheckPolynomial::new(vec![F::ZERO; 3]);

        let point = MultilinearPoint::new(vec![F::from_u64(5)]);
        assert_eq!(poly.evaluate_on_standard_domain(&point), F::ZERO);
    }

    #[test]
    fn test_linearity_of_evaluate_on_standard_domain() {
        // Test for a univariate polynomial.
        let evals1: Vec<_> = (1..=3).map(F::from_u64).collect();
        let evals2: Vec<_> = (10..=12).map(F::from_u64).collect();
        let poly1 = SumcheckPolynomial::new(evals1.clone());
        let poly2 = SumcheckPolynomial::new(evals2.clone());

        // Create a combined polynomial: poly1 + 2*poly2.
        let combined_evals: Vec<_> = evals1
            .iter()
            .zip(evals2.iter())
            .map(|(&e1, &e2)| e1 + e2.double())
            .collect();
        let combined_poly = SumcheckPolynomial::new(combined_evals);

        let point = MultilinearPoint::new(vec![F::from_u64(3)]);
        let expected = poly1.evaluate_on_standard_domain(&point)
            + poly2.evaluate_on_standard_domain(&point).double();
        assert_eq!(combined_poly.evaluate_on_standard_domain(&point), expected);
    }

    #[test]
    fn test_evaluate_on_standard_domain() {
        // Define a univariate function: f(0)=1, f(1)=2, f(2)=3.
        let evaluations: Vec<_> = (1..=3).map(F::from_u64).collect();
        let poly = SumcheckPolynomial::new(evaluations);

        // Define an evaluation point, e.g., x = 1/2.
        let point = MultilinearPoint::new(vec![F::from_u64(1) / F::from_u64(2)]);

        // Compute the expected result using the full Lagrange formula:
        // Σ f(i) * L_i(x) for i in {0,1,2}
        let expected_value = F::from_u64(1) * eq_poly3(&point, 0) // f(0) * L_0(x)
               + F::from_u64(2) * eq_poly3(&point, 1) // f(1) * L_1(x)
               + F::from_u64(3) * eq_poly3(&point, 2); // f(2) * L_2(x)

        let result = poly.evaluate_on_standard_domain(&point);
        assert_eq!(result, expected_value);
    }
}
